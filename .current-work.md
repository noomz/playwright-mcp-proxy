# Playwright MCP Proxy - Design & Implementation

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                MCP Client (stdio MCP Server)                 │
│  - Python MCP server using MCP SDK                          │
│  - Receives MCP tool calls via stdio from upstream client   │
│  - Translates to HTTP/JSON requests to local server         │
│  - Returns MCP responses with ref IDs (metadata only)       │
│  - Implementation: mcp.server.Server + httpx for HTTP       │
└────────────────────┬────────────────────────────────────────┘
                     │ HTTP/JSON (localhost:34501)
┌────────────────────▼────────────────────────────────────────┐
│                    HTTP Server                               │
│  - FastAPI server on port 34501                             │
│  - Manages Playwright MCP subprocess lifecycle:             │
│    * Spawns npx @playwright/mcp@latest on startup           │
│    * Health monitoring via periodic ping                    │
│    * Auto-restart on crash (max 3 retries)                  │
│    * Graceful shutdown on SIGTERM                           │
│  - Session management (UUID-based)                          │
│  - Request/response persistence to SQLite                   │
│  - Forwards requests to Playwright MCP via stdio           │
│  - Captures page snapshots and console logs                 │
└────────────────────┬────────────────────────────────────────┘
                     │ stdio (subprocess)
┌────────────────────▼────────────────────────────────────────┐
│            Upstream Playwright MCP Server                    │
│  - @playwright/mcp@latest (Node.js subprocess)              │
│  - Managed by HTTP server (spawn, monitor, restart)         │
│  - Manages actual browser instance                          │
│  - Provides all core browser automation tools               │
└─────────────────────────────────────────────────────────────┘
```

## Database Schema (SQLite)

### sessions
- session_id (TEXT PRIMARY KEY) - UUID v4
- created_at (TIMESTAMP)
- last_activity (TIMESTAMP)
- state (TEXT) - 'active', 'closed', 'error'
- metadata (JSON) - Additional session data

### requests
- ref_id (TEXT PRIMARY KEY) - UUID v4
- session_id (TEXT, FK to sessions)
- tool_name (TEXT) - e.g., 'browser_navigate'
- params (JSON) - Tool parameters
- timestamp (TIMESTAMP)

### responses
- ref_id (TEXT PRIMARY KEY, FK to requests)
- status (TEXT) - 'success', 'error'
- result (TEXT) - Full response from Playwright as JSON string (unparsed blob)
- page_snapshot (TEXT) - Accessibility tree snapshot as TEXT (raw string from MCP)
- console_logs (TEXT) - Array of console messages as JSON string (for backup/redundancy)
- error_message (TEXT, nullable)
- timestamp (TIMESTAMP)

**Storage Format Notes:**
- `result`: Stored as JSON string blob, exact bytes from Playwright MCP response
- `page_snapshot`: Stored as TEXT, preserving exact formatting from browser_snapshot
- `console_logs`: Stored as JSON string for redundancy (also normalized in console_logs table)
- This blob-based approach enables future diff implementation by comparing raw strings
- No transformation/parsing on write, only on read via get_content/get_console_content

### console_logs (normalized)
- id (INTEGER PRIMARY KEY AUTOINCREMENT)
- ref_id (TEXT, FK to responses)
- level (TEXT) - 'debug', 'info', 'warn', 'error'
- message (TEXT)
- timestamp (TIMESTAMP)
- location (JSON) - {url, lineNumber, columnNumber}

### diff_cursors (Phase 2 - Contracted Future Work)
- ref_id (TEXT PRIMARY KEY)
- cursor_position (INTEGER) - Byte offset for text comparison
- last_snapshot_hash (TEXT) - Hash of last returned content for change detection
- last_read (TIMESTAMP)

**Phase 2 Acceptance Criteria (ALL COMPLETE):**
- [x] get_content(ref_id) returns only content changed since last call for that ref_id
- [x] get_content(ref_id, reset_cursor=True) resets diff and returns full content
- [x] Cursor persists across server restarts (SQLite-backed)
- [x] Empty diff returns empty string (not error)
- [x] Initial read (no cursor) returns full content
- [x] Diff algorithm: simple string comparison (hash-based)
- [x] Console logs do NOT implement diff (always return full logs for ref_id)

## HTTP/JSON API Schema

### Request Format
```json
{
  "session_id": "uuid-v4-string",
  "tool": "tool_name",
  "params": {...},
  "request_id": "uuid-v4-string"  // Optional, generated if not provided
}
```

### Response Format
```json
{
  "ref_id": "uuid-v4-string",
  "session_id": "uuid-v4-string",
  "status": "success" | "error",
  "timestamp": "ISO8601",
  "metadata": {
    "tool": "tool_name",
    "has_snapshot": true,
    "has_console_logs": true,
    "console_error_count": 2
  },
  "error": "error message if status=error"
}
```

### Error Handling
```json
{
  "error": "error_type",
  "message": "Human-readable message",
  "details": {...}
}
```

## Tool Surface

### Proxied Tools (from Playwright MCP)
All upstream tools pass through with modified response format:
- browser_navigate
- browser_click
- browser_type
- browser_snapshot
- browser_console_messages
- browser_take_screenshot
- ... (all other Playwright tools)

### Extended Tools (new)

#### create_new_session
```
Returns: { "session_id": "uuid-v4" }
Side effect: Opens new Playwright browser session
```

#### get_content
```
Parameters:
  - ref_id: string (required)
  - search_for: string (optional) - substring filter
Returns: string (page snapshot from SQLite)
```

#### get_console_content
```
Parameters:
  - ref_id: string (required)
  - level: "debug" | "info" | "warn" | "error" | "" (optional, default: all)
Returns: string (formatted console logs)
```

## Implementation Plan

### Phase 1: Core Infrastructure
1. Set up UV project structure
2. Define SQLite schema and migrations
3. Implement database layer (using aiosqlite)
4. Create HTTP server skeleton (FastAPI)
5. Implement MCP client skeleton (using mcp SDK)

### Phase 2: Session Management
1. create_new_session tool
2. Session lifecycle (create, track, close)
3. Session-scoped Playwright connection

### Phase 3: Request/Response Persistence
1. UUID generation for requests
2. Request logging to SQLite
3. Response capture and storage
4. Page snapshot extraction
5. Console log capture

### Phase 4: Content Retrieval
1. get_content implementation
2. get_console_content implementation
3. Search/filter functionality

### Phase 5: Response Policy
1. Modify response format to return metadata + ref_id
2. Suppress full payload in MCP responses
3. Suppress console logs by default

### Phase 6: Diff Support (Contracted Future - Phase 2)
**See acceptance criteria in Database Schema section**
1. Implement diff_cursors table and migrations
2. Add cursor tracking to get_content
3. Implement reset_cursor parameter
4. Add hash-based change detection
5. Test diff with multiple sequential reads
6. Verify cursor persistence across server restarts

### Phase 7: Restart Recovery (Important but Not Urgent)
**Short-term behavior (Phase 1):**
- Server crash = all sessions lost
- MCP client reconnects to new HTTP server instance
- SQLite data persists but sessions marked as 'closed'
- Client must call create_new_session() to start fresh
- Historical data (requests/responses) remains queryable via get_content

**Long-term tasks (Future Phase 7):**
- [ ] Persist active session state (current URL, cookies, storage)
- [ ] On startup, detect unclosed sessions in SQLite
- [ ] Implement session rehydration: restore browser state from last snapshot
- [ ] Reconnect MCP client to rehydrated sessions
- [ ] Add session_resume(session_id) tool
- [ ] Handle edge cases: stale sessions, browser state drift
- [ ] Document rehydration limitations (ephemeral state like dialogs won't restore)

## Subprocess Lifecycle Management

The HTTP server owns and manages the Playwright MCP subprocess:

### Startup
1. On HTTP server start, spawn: `npx @playwright/mcp@latest`
2. Capture stdin/stdout/stderr pipes
3. Send initial MCP handshake (initialize)
4. Wait for successful initialization response
5. Mark subprocess as "healthy"
6. Start background health monitor task

### Health Monitoring
- Periodic ping every 30 seconds (configurable)
- Use MCP ping request or simple JSON-RPC ping
- If ping fails 3 consecutive times, mark as "unhealthy"
- Check subprocess.poll() to detect crashes
- Monitor stderr for critical errors

### Restart Policy
- On crash/unhealthy: attempt restart (max 3 times per 5 minutes)
- Backoff: 1s, 2s, 4s between restarts
- If max retries exceeded, mark server as degraded
- New incoming requests return 503 Service Unavailable
- Log all restart events with timestamps

### Graceful Shutdown
1. On SIGTERM/SIGINT, send browser_close to all active sessions
2. Wait up to 5 seconds for graceful close
3. Send SIGTERM to subprocess
4. Wait 2 seconds for subprocess exit
5. Send SIGKILL if still alive
6. Close HTTP server

### Error Handling
- Subprocess spawn failure: retry with exponential backoff
- Subprocess stderr: log all output for debugging
- Broken pipe: detect and restart subprocess
- Zombie processes: reap with periodic waitpid

## Configuration

### Server Configuration
```python
# server_config.py
SERVER_HOST = "localhost"
SERVER_PORT = 34501
DATABASE_PATH = "./proxy.db"
PLAYWRIGHT_MCP_COMMAND = ["npx", "@playwright/mcp@latest"]
```

### Playwright Launch Options
```python
# Can be configured via environment or config file
PLAYWRIGHT_BROWSER = "chrome"  # chrome, firefox, webkit
PLAYWRIGHT_HEADLESS = False
PLAYWRIGHT_VIEWPORT = {"width": 1280, "height": 720}
```

## Testing Strategy

### Unit Tests
- Database operations (CRUD)
- Session management
- UUID generation
- Response parsing
- Blob storage format validation

### Integration Tests
- MCP client <-> HTTP server communication
- HTTP server <-> Playwright MCP communication
- End-to-end request flow
- Session isolation
- Subprocess lifecycle (spawn, monitor, graceful shutdown)

### Resiliency Tests
**Crash/Reconnect Scenarios (Critical for Phase 1):**
- [ ] Kill HTTP server mid-session, verify SQLite data intact
- [ ] MCP client reconnects after server restart
- [ ] Create new session after reconnect
- [ ] Query historical data (get_content) from pre-crash sessions
- [ ] Verify old sessions marked 'closed' in DB
- [ ] Playwright subprocess crash triggers auto-restart (max 3 retries)
- [ ] HTTP server shutdown while MCP client active
- [ ] Concurrent requests during subprocess restart

**Phase 2 Additions:**
- [ ] Diff cursors survive server restart
- [ ] Resumed reads return correct delta

### Manual Testing
- Use `playwright` tool for interactive testing
- Test with real web pages
- Verify persistence across restarts
- Simulate crash with `kill -9` and verify recovery

## Dependencies (UV)

### MCP Client Component
- mcp (Python MCP SDK)
- httpx (for HTTP requests to server)
- pydantic (data validation)

### HTTP Server Component
- fastapi (HTTP server framework)
- uvicorn (ASGI server)
- aiosqlite (async SQLite)
- pydantic (data validation)
- psutil (subprocess monitoring)

### Shared
- python-dotenv (configuration)
- pytest + pytest-asyncio (testing)

## Current Status
- [x] Requirements analysis
- [x] Architecture design (initial)
- [x] Design refinements based on feedback:
  - [x] Clarified MCP client uses MCP SDK (not FastAPI)
  - [x] Added subprocess lifecycle management details
  - [x] Specified blob storage formats for diff compatibility
  - [x] Made diff support contracted Phase 2 with acceptance criteria
  - [x] Documented short-term restart behavior (full reset)
  - [x] Added crash/reconnect testing scenarios
- [x] Phase 1 Implementation Complete:
  - [x] Project structure with UV
  - [x] Configuration system (Pydantic Settings)
  - [x] SQLite database schema and operations
  - [x] HTTP server with FastAPI (all endpoints)
  - [x] Playwright subprocess manager (lifecycle, health, restart)
  - [x] MCP client with stdio protocol
  - [x] All core tools (create_session, get_content, get_console_content, proxied tools)
  - [x] Database tests (6 tests, all passing)
  - [x] Documentation (README, CHANGELOG, .env.example)
  - [x] Example scripts
- [x] Phase 2 Implementation Complete:
  - [x] Diff cursor database model and operations
  - [x] Hash-based change detection (SHA256)
  - [x] get_content endpoint with diff logic
  - [x] reset_cursor parameter support
  - [x] MCP client updated with reset_cursor parameter
  - [x] Diff tests (8 tests, all passing)
  - [x] Documentation updates (README, CHANGELOG)
  - [x] All 7 acceptance criteria met

## Notes
- Keep it simple: Only implement required features
- Reuse Playwright MCP where possible
- Focus on reliability and persistence
- Phase 1 response: metadata + ref_id only
- Console logs suppressed by default
- Diff support is contracted future work (Phase 2), not optional
- Restart recovery is important but deferred (Phase 7)
- Blob storage preserves exact bytes for future diff implementation
